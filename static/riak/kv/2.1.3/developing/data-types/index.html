<!DOCTYPE html>

<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"></html><![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8" lang="en"></html><![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9" lang="en"></html><![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" lang="en"><!--<![endif]-->




<head class="tutorials">
  <meta charset="utf-8">
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <meta name="viewport" content="width=device-width">
  <meta name="project" content="riak_kv">
  <meta name="version" content="2.1.3">
  <meta name="base-url" content="">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

  <title>Data Types</title>

  <link href="/css/all.css" media="screen" rel="stylesheet" type="text/css">
  <link href="/css/print.css" media="print" rel="stylesheet" type="text/css">

  
  <style type="text/css"> .js_enabled pre { visibility : hidden; } </style>
  <script type="text/javascript">
    document.documentElement.className = 'js_enabled';
  </script>
</head>



<body class="riak_kv 2.1.3 latest ">

  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-T9C8MK" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-T9C8MK');</script>

  
<aside id="nav-container" role="complementary">
  <nav class="overview" id="primary-nav" role="nav">
    <div id="primary-nav-content">
      <h2 class="responsive-link"><a class="responsive-toggle"></a></h2>

      
      <form id="searchbox_011972015458788978446:zgdcy4fa-o0" action="">
        <div class="nav-field-container">
          <div id="icon-container-search">
            <div class="icon-container"><span aria-hidden="true" class="nav-icon-search icon-search"></span></div>
            <span class="separator">&#124;</span>
          </div>
          <input id="main-search" name="q" placeholder="Search" size="5" type="search" />
        </div>
      </form>

      <div class="clear"></div>

      
      <h3 class="responsive-link visit-basho">
        <a href="http://www.basho.com">
          <div class="icon-container">
            <span aria-hidden="true" class="nav-icon" data-icon="&#xe003;"></span>
          </div>
          <span class="separator">&#124;</span>
          <span class="menu-title">Visit Basho</span>
          <div class="clear"></div>
        </a>
      </h3>

      
      <h3 class="responsive-link">
        <a href="/index.html">
          <div class="icon-container">
            <span aria-hidden="true" class="nav-icon" data-icon="&#xe003;"></span>
          </div>
          <span class="separator">&#124;</span>
          <span class="menu-title">All Riak Projects</span>
          <div class="clear"></div>
        </a>
      </h3>

      
      
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-riak"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/">Riak KV</a></span>
        <div class="clear"></div>
      </h3>
      
       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-download-alt"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/downloads/">Download Riak KV</a></span>
        <div class="clear"></div>
      </h3>
      
       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-install"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/setup/">Setup</a></span>
        <div class="clear"></div>
      </h3>
      
      
        
<ul class="depth-1">
  
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/setup/planning/">Planning</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/start/">Start Planning</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/operating-system/">OS Support</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/setup/planning/backend/">Choosing a Backend</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/backend/bitcask/">Bitcask</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/backend/leveldb/">LevelDB</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/backend/memory/">Memory</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/backend/multi/">Multi-backend</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/cluster-capacity/">Cluster Capacity</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/bitcask-capacity-calc/">Bitcask Capacity Calculator</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/best-practices/">Best Practices</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/planning/future/">Planning for the Future</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/setup/installing/">Installing</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/amazon-web-services/">Amazon Web Services</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/debian-ubuntu/">Debian &amp; Ubuntu</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/freebsd/">FreeBSD</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/mac-osx/">Mac OS X</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/rhel-centos/">RHEL &amp; CentOS</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/smartos/">SmartOS</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/solaris/">Solaris</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/suse/">SUSE</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/windows-azure/">Windows Azure</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/setup/installing/source/">Installing From Source</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/source/erlang/">Installing Erlang</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/source/jvm/">Installing the JVM</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/installing/verify/">Verifying an Installation</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/setup/upgrading/">Upgrading</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/setup/upgrading/checklist/">Production Checklist</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/upgrading/version/">Upgrading by Version</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/upgrading/cluster/">Upgrading a Cluster</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/upgrading/multi-datacenter/">Upgrading Multi-Datacenter</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/setup/upgrading/downgrade/">Downgrading</a>
  
  </li></ul>

  
  </li></ul>

       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-cog"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/configuring/">Configuring</a></span>
        <div class="clear"></div>
      </h3>
      
      
        
<ul class="depth-1">
  
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/basic/">Basic Configuration</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/backend/">Backend Configuration</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/managing/">Managing Configuration</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/reference/">Configuration Reference</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/strong-consistency/">Implementing Strong Consistency</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/load-balancing-proxy/">Load Balancing &amp; Proxy</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/mapreduce/">MapReduce Settings</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/search/">Search Settings</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/configuring/v3-multi-datacenter/">V3 Multi-Datacenter</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v3-multi-datacenter/quick-start/">Quickstart</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v3-multi-datacenter/nat/">With NAT</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v3-multi-datacenter/ssl/">SSL</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/configuring/v2-multi-datacenter/">V2 Multi-Datacenter</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v2-multi-datacenter/quick-start/">Quickstart</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v2-multi-datacenter/nat/">With NAT</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/configuring/v2-multi-datacenter/ssl/">SSL</a>
  
  </li></ul>

  
  </li></ul>

       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-database"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/using/">Using</a></span>
        <div class="clear"></div>
      </h3>
      
      
        
<ul class="depth-1">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/running-a-cluster/">Running a Cluster</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/admin/">Cluster Administration</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/admin/commands/">Cluster Admin Commands</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/admin/riak-admin/">riak-admin CLI</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/admin/riak-cli/">riak CLI</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/admin/riak-control/">Riak Control</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/cluster-operations/">Cluster Operations</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/adding-removing-nodes/">Adding/Removing Nodes</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/changing-cluster-info/">Changing Cluster Information</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/replacing-node/">Replacing a Node</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/inspecting-node/">Inspecting a Node</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/bucket-types/">Bucket Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/logging/">Logging</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/backing-up/">Backing Up</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/handoff/">Handoff</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/object-deletion/">Object Deletion</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/secondary-indexes/">Secondary Indexes</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/monitoring-strong-consistency/">Monitoring Strong Consistency</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/load-balancing/">Load Balancing</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/backend/">Backend</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/v3-multi-datacenter/">V3 Multi-Datacenter</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/cluster-operations/v2-multi-datacenter/">V2 Multi-Datacenter</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/repair-recovery/">Repair &amp; Recovery</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/repair-recovery/failure-recovery/">Failure &amp; Recovery</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/repair-recovery/errors/">Errors</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/repair-recovery/repairs/">Repairs</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/repair-recovery/rolling-restart/">Rolling Restarts</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/security/">Security</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/security/basics/">Security Basics</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/security/managing-sources/">Managing Security Sources</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/security/best-practices/">Best Practices</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/security/v2-v3-ssl-ca/">V2/V3 SSL &amp; CA Validation</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/performance/">Performance</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/performance/benchmarking/">Benchmarking</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/performance/open-files-limit/">Open Files Limit</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/performance/v2-scheduling-fullsync/">V2 Scheduling Fullsync</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/performance/multi-datacenter-tuning/">Multi-Datacenter Replication</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/troubleshooting/">Troubleshooting</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/">Product Advisories</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/210-dataloss/">Default Configuration For Handoff May Cause Data Loss</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/appconfig-foward/">Forward Incompatibility of app.config</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/dvv-lastwritewins/">Incompatibility between Dotted Version Vectors and Last Write Wins</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/maps-204/">Map Data Type Disk Incompatibility</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/product-advisories/ssl-poodle/">SSL 3.0 Vulnerability and POODLE Attack</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/troubleshooting/http-204/">HTTP 204</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/using/reference/">Reference</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/logging/">Logging</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/handoff/">Handoff</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/bucket-types/">Bucket Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/object-deletion/">Object Deletion</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/runtime-interaction/">Runtime Interaction</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/failure-recovery/">Failure &amp; Recovery</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/monitoring/">Monitoring</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/search-secondary-indexes/">Search &amp; Secondary Indexes</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/strong-consistency/">Strong Consistency</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/multi-datacenter/">Multi-Datacenter</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/v3/">V3 Replication</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/v2/">V2 Replication</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/using/reference/architecture/">Architecture</a>
  
  </li></ul>

  
  </li></ul>

       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-lambda"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/developing/">Developing</a></span>
        <div class="clear"></div>
      </h3>
      
      
        
<ul class="depth-1">
  
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/">Getting Started</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/java/">Java</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/java/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/java/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/java/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/ruby/">Ruby</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/ruby/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/ruby/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/ruby/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/python/">Python</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/python/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/python/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/python/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/csharp/">C Sharp</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/csharp/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/csharp/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/csharp/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/nodejs/">NodeJS</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/nodejs/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/nodejs/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/nodejs/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/erlang/">Erlang</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/erlang/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/erlang/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/erlang/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/golang/">Go</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/golang/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/golang/querying/">Querying</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/golang/object-modeling/">Object Modeling</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/getting-started/php/">PHP</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/php/crud-operations/">CRUD Operations</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/getting-started/php/querying/">Querying</a>
  
  </li></ul>

  
  </li></ul>

  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/usage/">Usage</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/creating-objects/">Creating Objects</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/reading-objects/">Reading Objects</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/updating-objects/">Updating Objects</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/deleting-objects/">Deleting Objects</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/content-types/">Content Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/search/">Searching</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/mapreduce/">Using MapReduce</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/secondary-indexes/">Using Secondary Indexes</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/bucket-types/">Bucket Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/commit-hooks/">Using Commit Hooks</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/search-schemas/">Creating Search Schemas</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/searching-data-types/">Searching with Data Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/document-store/">Implementing a Document Store</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/custom-extractors/">Custom Extractors</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/usage/security/">Security</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/security/java/">Java</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/security/ruby/">Ruby</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/security/python/">Python</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/security/erlang/">Erlang</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/security/php/">PHP</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/replication/">Replication</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/">Conflict Resolution</a></span></h4>
    
<ul class="depth-3">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/java/">Java</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/ruby/">Ruby</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/python/">Python</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/csharp/">C Sharp</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/nodejs/">NodeJS</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/php/">PHP</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/usage/conflict-resolution/golang/">Go</a>
  
  </li></ul>

  
  </li></ul>

  
  </li>
  <li class="current">
  
    <a href="/riak/kv/2.1.3/developing/data-types/">Data Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/data-modeling/">Data Modeling</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/app-guide/">Application Guide</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/app-guide/replication-properties/">Replication Properties</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/app-guide/strong-consistency/">Strong Consistency</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/app-guide/write-once/">Write Once</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/app-guide/reference/">Reference</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/client-libraries/">Client Libraries</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/developing/api/">APIs</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/developing/api/repl-hooks/">V2 Multi-Datacenter REPL Hooks API</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/api/backend/">Backend API</a>
  
  </li></ul>

  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/developing/faq/">Developing FAQ</a>
  
  </li></ul>

       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-beaker"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/riak/kv/2.1.3/learn/">Learning</a></span>
        <div class="clear"></div>
      </h3>
      
      
        
<ul class="depth-1">
  
  <li >
  
    <a href="/riak/kv/2.1.3/learn/why-riak-kv/">Why Riak KV?</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/use-cases/">Use Cases</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/new-to-nosql/">New to NoSQL?</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/glossary/">Riak KV Glossary</a>
  
  </li>
  <li >
  
    <h4><span><a href="/riak/kv/2.1.3/learn/concepts/">Concepts</a></span></h4>
    
<ul class="depth-2">
  
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/active-anti-entropy/">Active Anti-Entropy</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/buckets/">Buckets</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/capability-negotiation/">Capability Negotiation</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/causal-context/">Causal Context</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/clusters/">Clusters</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/crdts/">Data Types</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/eventual-consistency/">Eventual Consistency</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/keys-and-objects/">Keys and Objects</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/replication/">Replication</a>
  
  </li>
  <li >
  
    <a href="/riak/kv/2.1.3/learn/concepts/vnodes/">Vnodes</a>
  
  </li></ul>

  
  </li></ul>

       
      <h3>
        <div class="icon-container"><span aria-hidden="true" class="nav-icon icon-comments"></span>&nbsp;</div>
        <span class="separator">&#124;</span>
        <span class="menu-title"><a href="/community">Community</a></span>
        <div class="clear"></div>
      </h3>
      <ul></ul> 
    </div>
  </nav>

  
  <ul id="fixed-nav">
    <li>
      <a href="https://github.com/basho/basho_docs" target="_blank">
        <div class="icon-container">
          <span aria-hidden="true" class="nav-icon" data-icon="&#xe004;"></span>
        </div>
        <span class="separator">&#124;</span>Available on GitHub
      </a>
    </li>
    <li>
      <a href="/riak/latest/community/">
        <div class="icon-container">
          <span aria-hidden="true" class="nav-icon" data-icon="&#xf059;"></span>
        </div>
        <span class="separator">&#124;</span>Get Help
      </a>
    </li>
  </ul>
</aside>


  <script>
  (function() {
    var cx = '011972015458788978446:zgdcy4fa-o0';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div style="width:0px;overflow:hidden;height:0px;">
  <gcse:search></gcse:search>
</div>


  <div role="main">

    <header class="masthead">
  <div id="header">
    
    <div id="header-inner">
      <div class="icon-reorder" id="nav-toggle"></div>

      <div id="top-nav">
        
        <a href="/riak/kv/2.1.3/downloads/"><span class="icon-download-alt"></span>Downloads</a>
        <div id="nav-more"><span class="icon-more"></span></div>
      </div>

      <a class="responsive-toggle"></a>
      
      
      <a class="logo" href="/index.html"><h1>Riak Docs</h1></a>
      
      <span class="tagline">Product tutorials, how-tos, and fully-documented APIs.</span>
      <div id="nav-menu">
        <h2>Links</h2>
        <ul>
          <li><a href="http://docs.basho.com/">Docs Home</a></li>
          <li><a href="http://basho.com/">Basho Website</a></li>
        </ul>
        
        <div id="nav-menu-arrow"></div>
        <div id="nav-menu-arrow-back"></div>
      </div>

      <div class="clear"></div>

      <div class="header-rule"></div>
    </div>
  </div>
</header>


    <article class="mainarticle">

      <div class="versions">
  <div id="version-ddown-button" class="unselected">
    <div class="version-ddown-title">Version</div>
    <div class="version-ddown-number">2.1.3</div>
    <div class="version-ddown-arrow"></div>
  </div>
  <ol id="version-list" style="display: none;">
  
  
    
    
      
      
      <li class="sans versions-0 current">DEV</li>
      
      <li class="current versions-0"><a class="versioned" href="/riak/kv/2.1.3/developing/data-types/">2.1.3</a></li>
    
    
      
      
      
      <li class=" versions-0 first"><a class="versioned" href="/riak/kv/2.1.1/developing/data-types/">2.1.1</a></li>
    
  
    
    
      
      
      
      <li class="sans versions-1 current">LTS</li>
      <li class=" versions-1"><a class="versioned" href="/riak/kv/2.0.6/developing/data-types/">2.0.6</a></li>
    
      
      
      
      
      <li class=" versions-1"><a class="versioned" href="/riak/kv/2.0.5/developing/data-types/">2.0.5</a></li>
    
      
      
      
      
      <li class=" versions-1"><a class="versioned" href="/riak/kv/2.0.4/developing/data-types/">2.0.4</a></li>
    
      
      
      
      
      <li class=" versions-1"><a class="versioned" href="/riak/kv/2.0.2/developing/data-types/">2.0.2</a></li>
    
      
      
      
      
      <li class=" versions-1"><a class="versioned" href="/riak/kv/2.0.1/developing/data-types/">2.0.1</a></li>
    
    
      
      
      
      <li class=" versions-1 first"><a class="versioned" href="/riak/kv/2.0.0/developing/data-types/">2.0.0</a></li>
    
  
  
  <li class="versions-5 first"><a class="sans versioned" href="http://docs.basho.com/riak/1.4.12/">older</a></li>
  </ol>
</div>


      
      

      <header><h1>Data Types</h1></header>

      

      
      <nav id="toc">
        <h2 class="title">Contents</h2>
        <div id="toc-wrapper">
          <ol id="toc-items"></ol>
        </div>
      </nav>
      

      

<p>In versions 2.0 and greater, Riak users can make use of a variety of
Riak-specific data types inspired by research on convergent replicated
data types, more commonly known as <strong>CRDTs</strong>. For a more theoretical
treatment of how CRDTs work in Riak, see our [[Data Types]] doc.</p>

<p>While Riak was originally built as a mostly data-agnostic key/value
store, Riak Data Types enable you to use Riak as a <em>data-aware</em> system
in which you can perform a variety of transactions on five CRDT-inspired
data types: flags, registers, [[counters|Data Types#Counters]],
[[sets|Data Types#Sets]], and [[maps|Data Types#Maps]].</p>

<p>Of those five types, counters, sets, and maps can be used as
bucket-level data types, i.e. types that you can interact with directly.
Flags and registers, however, must be embedded in maps (more on that
[[below|Using Data Types#Maps]]).</p>

<div class="note">
<div class="title">Note on counters in earlier versions of Riak</div>
Counters are the one CRDT that was available in Riak prior to 2.0
(introduced in version 1.4). The implementation of counters in version 2.0
has been almost completely revamped, so if you are using Riak version
2.0 or later we strongly recommend that you follow the usage
documentation here rather than documentation for the older version of
counters.
</div>

<h2 id="setting-up-buckets-to-use-riak-data-types:31c17b0a2151a3c6671d36d00af76ad6">Setting Up Buckets to Use Riak Data Types</h2>

<p>In order to use Riak Data Types, you must first create a [[bucket
type|Using Bucket Types]] that sets the <code>datatype</code> bucket parameter to
either <code>counter</code>, <code>map</code>, or <code>set</code>.</p>

<p>The following would create a separate bucket type for each of the three
bucket-level data types:</p>

<pre><code class="language-bash">riak-admin bucket-type create maps '{&quot;props&quot;:{&quot;datatype&quot;:&quot;map&quot;}}'
riak-admin bucket-type create sets '{&quot;props&quot;:{&quot;datatype&quot;:&quot;set&quot;}}'
riak-admin bucket-type create counters '{&quot;props&quot;:{&quot;datatype&quot;:&quot;counter&quot;}}'
</code></pre>

<p><strong>Note</strong>: The names <code>maps</code>, <code>sets</code>, and <code>counters</code> are <em>not</em> reserved
terms. You are always free to name bucket types whatever you like, with
the exception of <code>default</code>.</p>

<p>Once you&rsquo;ve created a Riak-Data-Type-specific bucket type, you can check
to make sure that the bucket property configuration associated with that
type is correct. This can be done through the <code>riak-admin</code> interface.</p>

<pre><code class="language-bash">riak-admin bucket-type status maps
</code></pre>

<p>This will return a list of bucket properties and their associated values
in the form of <code>property: value</code>. If our <code>maps</code> bucket type has been set
properly, we should see the following pair in our console output:</p>

<pre><code>datatype: map
</code></pre>

<p>If a bucket type has been properly constructed, it needs to be activated
to be usable in Riak. This can also be done using the <code>bucket-type</code>
command interface:</p>

<pre><code class="language-bash">riak-admin bucket-type activate maps
</code></pre>

<p>To check whether activation has been successful, simply use the same
<code>bucket-type status</code> command shown above.</p>

<h2 id="data-types-and-search:31c17b0a2151a3c6671d36d00af76ad6">Data Types and Search</h2>

<p>Riak Data Types can be searched just like any other object, but with the
added benefit that you Data Type is indexed as a different type by Solr,
the search platform undergirding Riak Search. In our Search
documentation we offer a [[full tutorial|Using
Search#Riak-Data-Types-and-Search]] as well as a variety of
[[examples|Using Search#Data-Types-and-Search-Examples]], including code
samples from each of our official client libraries.</p>

<h2 id="usage-examples:31c17b0a2151a3c6671d36d00af76ad6">Usage Examples</h2>

<p>The examples below show you how to use Riak Data Types at the
application level using each of Basho&rsquo;s officially supported Riak
clients. All examples will use the bucket type names from above
(<code>counters</code>, <code>sets</code>, and <code>maps</code>). You&rsquo;re free to substitute your own
bucket type names if you wish.</p>

<h2 id="counters:31c17b0a2151a3c6671d36d00af76ad6">Counters</h2>

<p>Counters are a bucket-level Riak Data Type that can be used either by
themselves, i.e. associated with a bucket/key pair, or [[within a
map|Using Data Types#Maps]]. The examples in this section will show you
how to use counters on their own.</p>

<p>First, we need to point our client to the bucket type/bucket/key
location that will house our counter. We&rsquo;ll keep it simple and use the
<code>counters</code> bucket type created and activated above and a bucket called
<code>counters</code>.</p>

<pre><code class="language-java">// In the Java client, a bucket/bucket type combination is specified
// using a Namespace object. To specify bucket, bucket type, and key,
// use a Location object that incorporates the Namespace object, as is
// done below.
Namespace countersBucket = new Namespace(&quot;counters&quot;, &quot;counters&quot;);
Location location = new Location(countersBucket, &quot;&lt;insert_key_here&gt;&quot;);
</code></pre>

<pre><code class="language-ruby">bucket = client.bucket_type('counters').bucket('counters')
</code></pre>

<pre><code class="language-php">$bucket = new \Basho\Riak\Bucket('counters', 'counters');
</code></pre>

<pre><code class="language-python">bucket = client.bucket_type('counters').bucket('counters')
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

// You can either use the appropriate Options class or the Builder

// Options:
var options = new FetchCounterOptions(&quot;counters&quot;, &quot;counters&quot;, &quot;&lt;insert_key_here&gt;&quot;);

// Builder:
FetchCounter cmd = new FetchCounter.Builder()
    .WithBucketType(&quot;counters&quot;)
    .WithBucket(&quot;counters&quot;)
    .WithKey(&quot;&lt;insert_key_here&gt;&quot;)
    .Build();
</code></pre>

<pre><code class="language-javascript">// The following can be passed as options to FetchCounter
var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: '&lt;insert_key_here&gt;'
};
</code></pre>

<pre><code class="language-erlang">%% Buckets are simply named binaries in the Erlang client. See the
%% examples below for more information
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/counters/buckets/counters/datatypes/&lt;key&gt;

# Note that this differs from the URL structure for non-Data-Type
# requests, which end in /keys/&lt;key&gt;
</code></pre>

<div class="note">
<div class="title">Getting started with Riak clients</div>
If you are connecting to Riak using one of Basho's official [[client
libraries]], you can find more information about getting started with
your client in our [[quickstart guide|Five-Minute
Install#setting-up-your-riak-client]].
</div>

<p>To create a counter, you need to specify a bucket/key pair to hold that
counter. Here is the general syntax for doing so:</p>

<pre><code class="language-java">// Here, we'll use the Namespace object that we created above and
// incorporate it into a Location object that includes the key (as yet
// unspecified) for our counter

// Using the countersBucket Namespace object from above:
Location counter = new Location(countersBucket, &quot;&lt;key&gt;&quot;);

// Or we can specify the Location all at once:
Location counter = new Location(new Namespace(&quot;counters&quot;, &quot;counters&quot;), &quot;&lt;key&gt;&quot;);
</code></pre>

<pre><code class="language-ruby">counter = Riak::Crdt::Counter.new(bucket, key, bucket_type)

# Or you can specify a bucket and bucket type all at once and pass that
# into the constructor
bucket = client.bucket_type(bucket_type).bucket(bucket)
counter = Riak::Crdt::Counter.new(bucket, key)
</code></pre>

<pre><code class="language-php"># using the $bucket var created earlier
$location = new \Basho\Riak\Location('key', $bucket);
</code></pre>

<pre><code class="language-python"># The client detects the bucket-type's Data Type and automatically
# returns the right datatype for you, in this case a counter
counter = bucket.new(key)

# This way is also acceptable:
from riak.datatypes import Counter

counter = Counter(bucket, key)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var fetchCounterOptions = new FetchCounterOptions(&quot;counters&quot;, &quot;counters&quot;, &quot;&lt;key&gt;&quot;);
FetchCounter cmd = new FetchCounter(fetchCounterOptions);
RiakResult rslt = client.Execute(cmd);
CounterResponse response = cmd.Response;
</code></pre>

<pre><code class="language-javascript">// The following can be passed as options to the *Counter methods on the
// Node.js Client object
var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: '&lt;insert_key_here&gt;'
};
</code></pre>

<pre><code class="language-erlang">%% Counters are not encapsulated with the bucket/key in the Erlang
%% client. See the examples below for more information.
</code></pre>

<pre><code class="language-curl"># This will create a counter with an initial value of 0

curl -XPOST http://localhost:8098/types/counters/buckets/&lt;bucket&gt;/datatypes/&lt;key&gt; \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;increment&quot;: 0}'
</code></pre>

<p>Let&rsquo;s say that we want to create a counter called <code>traffic_tickets</code> in
our <code>counters</code> bucket to keep track of our legal misbehavior. We can
create this counter and ensure that the <code>counters</code> bucket will use our
<code>counters</code> bucket type like this:</p>

<pre><code class="language-java">// Using the countersBucket Namespace object from above:

Location trafficTickets = new Location(countersBucket, &quot;traffic_tickets&quot;);
</code></pre>

<pre><code class="language-ruby">bucket = client.bucket_type('counters').bucket('counters')
counter = Riak::Crdt::Counter.new(bucket, 'traffic_tickets')

# Alternatively, the Ruby client enables you to set a bucket type as
# being globally associated with a Riak Data Type. The following would
# set all counter buckets to use the counters bucket type:

Riak::Crdt::DEFAULT_BUCKET_TYPES[:counter] = 'counters'

# This would enable us to create our counter without specifying a bucket type
bucket = client.bucket('counters')
counter = Riak::Crdt::Counter.new(bucket, 'traffic_tickets')
</code></pre>

<pre><code class="language-php"># using the $bucket var created earlier
$location = new \Basho\Riak\Location('traffic_tickets', $bucket);
</code></pre>

<pre><code class="language-python">bucket = client.bucket_type('counters').bucket('traffic_tickets')
counter = bucket.new('traffic_tickets')
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var fetchCounterOptions = new FetchCounterOptions(&quot;counters&quot;, &quot;counters&quot;, &quot;traffic_tickts&quot;);
FetchCounter cmd = new FetchCounter(fetchCounterOptions);
RiakResult rslt = client.Execute(cmd);
CounterResult = cmd.Result;
</code></pre>

<pre><code class="language-javascript">// Using the options from above:

var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: 'traffic_tickets'
};
</code></pre>

<pre><code class="language-erlang">Counter = riakc_counter:new().

%% Counters in the Erlang client are opaque data structures that collect
%% operations as you mutate them. We will associate the data structure
%% with a bucket type, bucket, and key later on.
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/counters/buckets/counters/datatypes/traffic_tickets \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;increment&quot;: 0}'
</code></pre>

<p>Now that our client knows which bucket/key pairing to use for our
counter, <code>traffic_tickets</code> will start out at 0 by default. If we happen
to get a ticket that afternoon, we would need to increment the counter:</p>

<pre><code class="language-java">// Using the &quot;trafficTickets&quot; Location from above:

CounterUpdate cu = new CounterUpdate(1);
UpdateCounter update = new UpdateCounter.Builder(trafficTickets, cu)
    .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">counter.increment

# This will increment the counter both on the application side and in
Riak
</code></pre>

<pre><code class="language-php">(new \Basho\Riak\Command\Builder\IncrementCounter($riak))
    -&gt;withIncrement(1)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">counter.increment()

# Updates are staged locally and have to be explicitly sent to Riak
# using the store() method.
counter.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

UpdateCounter updateCmd = new UpdateCounter.Builder(increment: 1)
    .WithBucketType(&quot;counters&quot;)
    .WithBucket(&quot;counters&quot;)
    .WithKey(&quot;traffic_tickets&quot;)
    .WithReturnBody(true)
    .Build();

RiakResult rslt = client.Execute(updateCmd);
CounterResponse response = updateCmd.Response;
// response.Value will be 1
</code></pre>

<pre><code class="language-javascript">// Using the options from above:

var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: 'traffic_tickets',
    increment: 1
};
client.updateCounter(options,
    function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
</code></pre>

<pre><code class="language-erlang">Counter1 = riakc_counter:increment(Counter).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/counters/buckets/counters/datatypes/traffic_tickets \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;increment&quot;: 1}'
</code></pre>

<p>The default value of an increment operation is 1, but you can increment
by more than one if you&rsquo;d like (but always by an integer). Let&rsquo;s say
that we decide to spend an afternoon flaunting traffic laws and manage
to rack up five tickets:</p>

<pre><code class="language-java">// Using the &quot;trafficTickets&quot; Location from above:
CounterUpdate cu = new CounterUpdate(5);
UpdateCounter update = new UpdateCounter.Builder(trafficTickets, cu)
    .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">counter.increment(5)
</code></pre>

<pre><code class="language-php">(new \Basho\Riak\Command\Builder\IncrementCounter($riak))
    -&gt;withIncrement(5)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">counter.increment(5)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var builder = new UpdateCounter.Builder(5)
    .WithBucketType(&quot;counters&quot;)
    .WithBucket(&quot;counters&quot;)
    .WithKey(&quot;traffic_tickets&quot;)
    .WithReturnBody(true);

UpdateCounter updateCmd = builder.Build();

rslt = client.Execute(updateCmd);
CounterResponse response = updateCmd.Response;
// response.Value is 5 more than before

// To decrement:
// Modify the builder's increment, then construct a new command
builder.WithIncrement(-5);
updateCmd = builder.Build();

rslt = client.Execute(updateCmd);
CheckResult(rslt);

response = updateCmd.Response;
// response.Value is 5 less than before
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: 'traffic_tickets',
    increment: 5
};
client.updateCounter(options,
    function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
</code></pre>

<pre><code class="language-erlang">Counter2 = riakc_counter:increment(5, Counter1).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/counters/buckets/counters/datatypes/traffic_tickets \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;increment&quot;: 5}'
</code></pre>

<p>If we&rsquo;re curious about how many tickets we have accumulated, we can
simply retrieve the value of the counter at any time:</p>

<pre><code class="language-java">// Using the &quot;trafficTickets&quot; Location from above:
FetchCounter fetch = new FetchCounter.Builder(trafficTickets)
    .build();
FetchCounter.Response response = client.execute(fetch);
RiakCounter counter = response.getDatatype();
Long ticketsCount = counter.view();
</code></pre>

<pre><code class="language-ruby">counter.value
# Output will always be an integer
</code></pre>

<pre><code class="language-php">$trafficTickets = (new \Basho\Riak\Command\Builder\FetchCounter($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getCounter();

$trafficTickets-&gt;getData(); # returns an integer
</code></pre>

<pre><code class="language-python">counter.dirty_value

# The value fetched from Riak is always immutable, whereas the &quot;dirty
# value&quot; takes into account local modifications that have not been
# sent to the server. For example, whereas the call above would return
# 6, the call below will return 0' since we started with an empty
# counter:

counter.value

# To fetch the value stored on the server, use the call below. Note
# that this will clear any changes to the counter that have not yet been
# sent to Riak
counter.reload()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var fetchCounterOptions = new FetchCounterOptions(&quot;counters&quot;, &quot;counters&quot;, &quot;traffic_tickts&quot;);
FetchCounter cmd = new FetchCounter(fetchCounterOptions);
RiakResult rslt = client.Execute(cmd);
CounterResponse response = cmd.Response;
// response.Value has the counter value
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'counters',
    bucket: 'counters',
    key: 'traffic_tickets'
};
client.fetchCounter(options,
    function (err, rslt) {
        if (err) {
            throw new Error(err);
        }

        if (rslt.notFound) {
            logger.error(&quot;bt: %s, b: %s, k: %s, counter: NOT FOUND&quot;,
                options.bucketType, options.bucket, options.key);
        } else {
            logger.info(&quot;bt: %s, b: %s, k: %s, counter: %d&quot;,
                options.bucketType, options.bucket, options.key,
                rslt.counterValue);
        }
    }
);
</code></pre>

<pre><code class="language-erlang">riakc_counter:dirty_value(Counter2).

%% The value fetched from Riak is always immutable, whereas the &quot;dirty
%% value&quot; takes into account local modifications that have not been
%% sent to the server. For example, whereas the call above would return
%% '6', the call below will return '0' since we started with an empty
%% counter:

riakc_counter:value(Counter2).

%% To fetch the value stored on the server, use the call below:

{ok, CounterX} = riakc_pb_socket:fetch_type(Pid,
                                            {&lt;&lt;&quot;counters&quot;&gt;&gt;, &lt;&lt;&quot;counters&quot;&gt;&gt;},
                                            &lt;&lt;&quot;traffic_tickets&quot;&gt;&gt;).
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/counters/buckets/counters/datatypes/traffic_tickets

# Response:
{&quot;type&quot;:&quot;counter&quot;, &quot;value&quot;: &lt;value&gt;}
</code></pre>

<p>For a counter to be useful, you need to be able to decrement it in
addition to incrementing it. Riak counters enable you to do precisely
that. Let&rsquo;s say that we hire an expert lawyer who manages to get one of
our traffic tickets stricken from our record:</p>

<pre><code class="language-java">// Using the &quot;trafficTickets&quot; Location from above:
CounterUpdate cu = new CounterUpdate(-1);
UpdateCounter update = new UpdateCounter.Builder(trafficTickets, cu)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">counter.decrement

# Just like incrementing, you can also decrement by more than one, e.g.:
counter.decrement(3)
</code></pre>

<pre><code class="language-php">(new \Basho\Riak\Command\Builder\IncrementCounter($riak))
    -&gt;withIncrement(-3)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">counter.decrement()

# Just like incrementing, you can also decrement by more than one, e.g.:
counter.decrement(3)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var updateCmd = new UpdateCounter.Builder(-3)
    .WithBucketType(&quot;counters&quot;)
    .WithBucket(&quot;counters&quot;)
    .WithKey(&quot;traffic_tickets&quot;)
    .Build();

rslt = client.Execute(updateCmd);
response = updateCmd.Response;
// response.Value is three less than before
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'counters',
    bucket: 'counter',
    key: 'traffic_tickets',
    increment: -1
};

// As with incrementing, you can also decrement by more than one, e.g.:
var options = {
    bucketType: 'counters',
    bucket: 'counter',
    key: 'traffic_tickets',
    increment: -3
};
</code></pre>

<pre><code class="language-erlang">Counter3 = riakc_counter:decrement(Counter2).

%% As with incrementing, you can also decrement by more than one:

Counter4 = riakc_counter:decrement(3, Counter3).

%% At some point, we'll want to send our local updates to the server
%% so they get recorded and are visible to others. Extract the update
%% using the to_op/1 function, then pass it to
%% riakc_pb_socket:update_type/4,5.

riakc_pb_socket:update_type(Pid, {&lt;&lt;&quot;counters&quot;&gt;&gt;,&lt;&lt;&quot;counters&quot;&gt;&gt;},
                            &lt;&lt;&quot;traffic_tickets&quot;&gt;&gt;,
                            riakc_counter:to_op(Counter4)).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/counters/buckets/counters/datatypes/traffic_tickets \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;decrement&quot;: 3}'
</code></pre>

<h2 id="sets:31c17b0a2151a3c6671d36d00af76ad6">Sets</h2>

<p>As with counters (and maps, as shown below), using sets involves setting
up a bucket/key pair to house a set and running set-specific operations
on that pair.</p>

<p>Here is the general syntax for setting up a bucket type/bucket/key
combination to handle a set:</p>

<pre><code class="language-java">// In the Java client, a bucket/bucket type combination is specified
// using a Namespace object. To specify bucket, bucket type, and key,
// use a Location object that incorporates the Namespace object, as is
// done below.

Location set =
  new Location(new Namespace(&quot;&lt;bucket_type&gt;&quot;, &quot;&lt;bucket&gt;&quot;), &quot;&lt;key&gt;&quot;);
</code></pre>

<pre><code class="language-ruby"># Note: both the Riak Ruby Client and Ruby the language have a class
# called Set. Make sure that you refer to the Ruby version as ::Set and
# the Riak client version as Riak::Crdt::Set

bucket = client.bucket_type('bucket_type_name').bucket('bucket_name')
set = Riak::Crdt::Set.new(bucket, key)
</code></pre>

<pre><code class="language-php">$location = new \Basho\Riak\Location('key', new \Basho\Riak\Bucket('bucket_name', 'bucket_type'));
</code></pre>

<pre><code class="language-python"># Note: The Python standard library `collections` module has an abstract
# base class called Set, which the Riak Client version subclasses as
# `riak.datatypes.Set`. These classes are not directly interchangeable.
# In addition to the base methods, `riak.datatypes.Set` also
# implements the `add` and `discard` methods from
# `collections.MutableSet`, but does not implement the rest of its
# API. Be careful when importing, or simply use the instances returned
# by `RiakBucket.get()` and `RiakBucket.new()` instead of directly
# importing the class.

set = bucket.new(key)

# or

from riak.datatypes import Set
set = Set(bucket, key)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

// As with counters, with the Riak .NET Client you interact with sets
// by building an Options object or using a Builder
var builder = new FetchSet.Builder()
    .WithBucketType(&quot;sets&quot;)
    .WithBucket(&quot;travel&quot;)
    .WithKey(&quot;cities&quot;);

// NB: builder.Options will only be set after Build() is called.
FetchSet fetchSetCommand = builder.Build();

FetchSetOptions options = new FetchSetOptions(&quot;sets&quot;, &quot;travel&quot;, &quot;cities&quot;);

// These two options objects are equal
Assert.AreEqual(options, builder.Options);
</code></pre>

<pre><code class="language-javascript">// As with counters, with the Riak Node.js Client you interact with sets on the
// basis of the set's location in Riak, as specified by an options object.
// Below is an example:
var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
</code></pre>

<pre><code class="language-erlang">%% Like counters, sets are not encapsulated in a
%% bucket/key in the Erlang client. See below for more
%% information.
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/&lt;bucket_type&gt;/buckets/&lt;bucket&gt;/datatypes/&lt;key&gt;

# Note that this differs from the URL structure for non-Data Type requests,
# which end in /keys/&lt;key&gt;
</code></pre>

<p>Let&rsquo;s say that we want to use a set to store a list of cities that we
want to visit. Let&rsquo;s create a Riak set stored in the key <code>cities</code> in the
bucket <code>travel</code> (using the <code>sets</code> bucket type we created in the previous
section):</p>

<pre><code class="language-java">// In the Java client, you specify the location of Data Types
// before you perform operations on them:

Location citiesSet =
  new Location(new Namespace(&quot;sets&quot;, &quot;travel&quot;), &quot;cities&quot;);
</code></pre>

<pre><code class="language-ruby">travel = client.bucket_type('sets').bucket('travel')
cities_set = Riak::Crdt::Set.new(travel, 'cities')

# Alternatively, the Ruby client enables you to set a bucket type as
# being globally associated with a Riak Data Type. The following would
# set all set buckets to use the sets bucket type:

Riak::Crdt::DEFAULT_BUCKET_TYPES[:set] = 'sets'

# This would enable us to create our set without specifying a bucket
# type:
travel = client.bucket('travel')
cities_set = Riak::Crdt::Set.new(travel, 'cities')
</code></pre>

<pre><code class="language-php">$location = new \Basho\Riak\Location('cities', 'travel', 'sets');
</code></pre>

<pre><code class="language-python">travel = client.bucket_type('sets').bucket('travel')

# The client detects the bucket type's Data Type and automatically
# returns the right Data Type for you, in this case a Riak set.
cities_set = travel.new('cities')

# You can also create a reference to a set explicitly:
from riak.datatypes import Set

cities_set = Set(travel, 'cities')
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

// Now we'll create a Builder object for the set with which we want to
// interact:
var builder = new FetchSet.Builder()
    .WithBucketType(&quot;sets&quot;)
    .WithBucket(&quot;travel&quot;)
    .WithKey(&quot;cities&quot;);
</code></pre>

<pre><code class="language-javascript">// Now we'll create a options object for the set with which we want to
// interact:
var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
</code></pre>

<pre><code class="language-erlang">CitiesSet = riakc_set:new().

%% Sets in the Erlang client are opaque data structures that
%% collect operations as you mutate them. We will associate the data
%% structure with a bucket type, bucket, and key later on.
</code></pre>

<pre><code class="language-curl"># You cannot create an empty set through the HTTP interface. Sets can
# only be created when an element is added to them, as in the examples
# below.
</code></pre>

<p>Upon creation, our set is empty. We can verify that it is empty at any
time:</p>

<pre><code class="language-java">// Using our &quot;cities&quot; Location from above:

FetchSet fetch = new FetchSet.Builder(citiesSet)
    .build();
FetchSet.Response response = client.execute(fetch);
RiakSet set = response.getDatatype();
boolean isEmpty = set.viewAsSet().isEmpty();
</code></pre>

<pre><code class="language-ruby">cities_set.empty?
</code></pre>

<pre><code class="language-php"># use $location from earlier
$set = (new \Basho\Riak\Command\Builder\FetchSet($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getSet();

count($set-&gt;getData());
</code></pre>

<pre><code class="language-python">len(cities_set) == 0
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var builder = new FetchSet.Builder()
    .WithBucketType(&quot;sets&quot;)
    .WithBucket(&quot;travel&quot;)
    .WithKey(&quot;cities&quot;);

FetchSet fetchSetCommand = builder.Build();
RiakResult rslt = client.Execute(fetchSetCommand);
SetResponse response = fetchSetCommand.Response;
// response.Value will be null
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
client.fetchSet(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    if (rslt.notFound) {
        logger.info(&quot;set 'cities' is not found!&quot;);
    }
});
</code></pre>

<pre><code class="language-erlang">riakc_set:size(CitiesSet) == 0.

%% Query functions like size/1, is_element/2, and fold/3 operate over
%% the immutable value fetched from the server. In the case of a new
%% set that was not fetched, this is an empty collection, so the size
%% is 0.
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/sets/buckets/travel/datatypes/cities

# Response
not found
</code></pre>

<p>But let&rsquo;s say that we read a travel brochure saying that Toronto and
Montreal are nice places to go. Let&rsquo;s add them to our <code>cities</code> set:</p>

<pre><code class="language-java">// Using our &quot;cities&quot; Location from above:

SetUpdate su = new SetUpdate()
        .add(&quot;Toronto&quot;)
        .add(&quot;Montreal&quot;);
UpdateSet update = new UpdateSet.Builder(citiesSet, su)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">cities_set.add('Toronto')
cities_set.add('Montreal')
</code></pre>

<pre><code class="language-php"># use $location from earlier
$response = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('Toronto')
    -&gt;add('Montreal')
    -&gt;atLocation($location)
    -&gt;withParameter('returnbody', 'true')
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">cities_set.add('Toronto')
cities_set.add('Montreal')
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var adds = new[] { &quot;Toronto&quot;, &quot;Montreal&quot; };

var builder = new UpdateSet.Builder()
    .WithBucketType(&quot;sets&quot;)
    .WithBucket(&quot;travel&quot;)
    .WithKey(&quot;cities&quot;)
    .WithAdditions(adds);

UpdateSet cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);
SetResponse response = cmd.Response;

Assert.Contains(&quot;Toronto&quot;, response.AsStrings.ToArray());
Assert.Contains(&quot;Montreal&quot;, response.AsStrings.ToArray());
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
var cmd = new Riak.Commands.CRDT.UpdateSet.Builder()
    .withBucketType(options.bucketType)
    .withBucket(options.bucket)
    .withKey(options.key)
    .withAdditions(['Toronto', 'Montreal'])
    .withCallback(
        function (err, rslt) {
            if (err) {
                throw new Error(err);
            }
        }
    )
    .build();
client.execute(cmd);
</code></pre>

<pre><code class="language-erlang">CitiesSet1 = riakc_set:add_element(&lt;&lt;&quot;Toronto&quot;&gt;&gt;, CitiesSet),
CitiesSet2 = riakc_set:add_element(&lt;&lt;&quot;Montreal&quot;&gt;&gt;, CitiesSet1).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/sets/buckets/travel/datatypes/cities \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;add_all&quot;:[&quot;Toronto&quot;, &quot;Montreal&quot;]}'
</code></pre>

<p>Later on, we hear that Hamilton and Ottawa are nice cities to visit in
Canada, but if we visit them, we won&rsquo;t have time to visit Montreal, so
we need to remove it from the list. It needs to be noted here that
removing an element from a set is a bit trickier than adding elements. In
order to remove an item (or multiple items), we need to first fetch the
set, which provides our client access to the set&rsquo;s [[causal context]].
Once we&rsquo;ve fetched the set, we can remove the element <code>Montreal</code> and
store the set.</p>

<pre><code class="language-java">// Using our &quot;citiesSet&quot; Location from above

// First, we get a response
FetchSet fetch = new FetchSet.Builder(citiesSet).build();
FetchSet.Response response = client.execute(fetch);

// Then we can fetch the set's causal context
Context ctx = response.getContext();

// Now we build a SetUpdate operation
SetUpdate su = new SetUpdate()
        .remove(&quot;Montreal&quot;)
        .add(&quot;Hamilton&quot;)
        .add(&quot;Ottawa&quot;);

// Finally, we update the set, specifying the context
UpdateSet update = new UpdateSet.Builder(citiesSet, su)
        .withContext(ctx)
        .build();
client.execute(update);

// More information on using causal context with the Java client can be
// found at the bottom of this document
</code></pre>

<pre><code class="language-ruby">cities_set.remove('Montreal')
cities_set.add('Hamilton')
cities_set.add('Ottawa')
</code></pre>

<pre><code class="language-php"># use $location &amp; $response from earlier
(new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('Hamilton')
    -&gt;add('Ottawa')
    -&gt;remove('Montreal')
    -&gt;atLocation($location)
    -&gt;withContext($response-&gt;getSet()-&gt;getContext())
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">cities_set.discard('Montreal')
cities_set.add('Hamilton')
cities_set.add('Ottawa')
cities_set.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var removes = new[] { &quot;Montreal&quot; };
var adds = new[] { &quot;Hamilton&quot;, &quot;Ottawa&quot; };

// Note:
// using the builder from above
// using the Context member from the above response
builder
    .WithAdditions(adds)
    .WithRemovals(removes)
    .WithContext(response.Context);

UpdateSet cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);
SetResponse response = cmd.Response;

// using System.Linq
var responseStrings = response.AsStrings.ToArray();

Assert.Contains(&quot;Toronto&quot;, responseStrings);
Assert.Contains(&quot;Hamilton&quot;, responseStrings);
Assert.Contains(&quot;Ottawa&quot;, responseStrings);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
client.fetchSet(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    // NB: clone package https://www.npmjs.com/package/clone
    var update_opts = clone(options);
    update_opts.context = rslt.context;
    update_opts.additions = ['Hamilton', 'Ottawa'];
    update_opts.removals = ['Montreal', 'Ottawa'];

    client.updateSet(update_opts, function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
});
</code></pre>

<pre><code class="language-erlang">CitiesSet3 = riakc_set:del_element(&lt;&lt;&quot;Montreal&quot;&gt;&gt;, CitiesSet2),
CitiesSet4 = riakc_set:add_element(&lt;&lt;&quot;Hamilton&quot;&gt;&gt;, CitiesSet3),
CitiesSet5 = riakc_set:add_element(&lt;&lt;&quot;Ottawa&quot;&gt;&gt;, CitiesSet4).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/sets/buckets/travel/datatypes/cities \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;remove&quot;: &quot;Montreal&quot;,&quot;add_all&quot;:[&quot;Hamilton&quot;, &quot;Ottawa&quot;]}'
</code></pre>

<p>Now, we can check on which cities are currently in our set:</p>

<pre><code class="language-java">// Using our &quot;cities&quot; Location from above:

FetchSet fetch = new FetchSet.Builder(citiesSet)
        .build();
FetchSet.Response response = client.execute(fetch);
Set&lt;BinaryValue&gt; binarySet = response.getDatatype().view();
for (BinaryValue city : binarySet) {
  System.out.println(city.toStringUtf8());
}
</code></pre>

<pre><code class="language-ruby">cities_set.members

#&lt;Set: {&quot;Hamilton&quot;, &quot;Ottawa&quot;, &quot;Toronto&quot;}&gt;
</code></pre>

<pre><code class="language-php"># use $location from earlier
$set = (new \Basho\Riak\Command\Builder\FetchSet($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getSet();

var_dump($set-&gt;getData());
</code></pre>

<pre><code class="language-python">cities_set.dirty_value

# The value fetched from Riak is always immutable, whereas the &quot;dirty
# value&quot; takes into account local modifications that have not been
# sent to the server. For example, where the call above would return
# frozenset(['Toronto', 'Hamilton', 'Ottawa']), the call below would
# return frozenset([]).

cities_set.value

# To fetch the value stored on the server, use the call below. Note
# that this will clear any unsent additions or deletions.
cities_set.reload()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

foreach (var value in setResponse.AsStrings)
{
    Console.WriteLine(&quot;Cities Set Value: {0}&quot;, value);
}

// Output:
// Cities Set Value: Hamilton
// Cities Set Value: Ottawa
// Cities Set Value: Toronto
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'sets',
    bucket: 'travel',
    key: 'cities'
};
client.fetchSet(options, function(err, rslt) {
    if (err) {
        throw new Error(err);
    }

    logger.info(&quot;cities set values: '%s'&quot;,
        rslt.values.join(', '));
});

// Output:
// info: cities set values: 'Hamilton, Ottawa, Toronto'
</code></pre>

<pre><code class="language-erlang">riakc_set:dirty_value(CitiesSet5).

%% The value fetched from Riak is always immutable, whereas the &quot;dirty
%% value&quot; takes into account local modifications that have not been
%% sent to the server. For example, where the call above would return
%% [&lt;&lt;&quot;Hamilton&quot;&gt;&gt;, &lt;&lt;&quot;Ottawa&quot;&gt;&gt;, &lt;&lt;&quot;Toronto&quot;&gt;&gt;], the call below would
%% return []. These are essentially ordsets:

riakc_set:value(CitiesSet5).

%% To fetch the value stored on the server, use the call below:

{ok, SetX} = riakc_pb_socket:fetch_type(Pid,
                                        {&lt;&lt;&quot;sets&quot;&gt;&gt;,&lt;&lt;&quot;travel&quot;&gt;&gt;},
                                         &lt;&lt;&quot;cities&quot;&gt;&gt;).
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/sets/buckets/travel/datatypes/cities

# Response

{&quot;type&quot;:&quot;set&quot;,&quot;value&quot;:[&quot;Hamilton&quot;, &quot;Ottawa&quot;, &quot;Toronto&quot;],&quot;context&quot;:&quot;SwGDUAAAAER4ActgymFgYGDMYMoFUhxHgzZyBzMfsU9kykISZg/JL8rPK8lHEkKoZMzKAgDwJA+e&quot;}

# You can also fetch the value of the set without the context included:
curl http://localhost:8098/types/sets/buckets/travel/datatypes/cities?include_context=false

# Response
{&quot;type&quot;:&quot;set&quot;,&quot;value&quot;:[&quot;Hamilton&quot;, &quot;Ottawa&quot;, &quot;Toronto&quot;]}
</code></pre>

<p>Or we can see whether our set includes a specific member:</p>

<pre><code class="language-java">// Using our &quot;citiesSet&quot; from above:

System.out.println(citiesSet.contains((&quot;Vancouver&quot;));
System.out.println(citiesSet.contains(&quot;Ottawa&quot;));
</code></pre>

<pre><code class="language-ruby">cities_set.include? 'Vancouver'
# false

cities_set.include? 'Ottawa'
# true
</code></pre>

<pre><code class="language-php">in_array('Vancouver', $set-&gt;getData()); # false

in_array('Ottawa', $set-&gt;getData()); # true
</code></pre>

<pre><code class="language-python">'Vancouver' in cities_set
# False

'Ottawa' in cities_set
# True
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

using System.Linq;

bool includesVancouver = response.AsStrings.Any(v =&gt; v == &quot;Vancouver&quot;);
bool includesOttawa = response.AsStrings.Any(v =&gt; v == &quot;Ottawa&quot;);
</code></pre>

<pre><code class="language-javascript">// Use standard javascript array method indexOf()

var cities_set = result.values;
cities_set.indexOf('Vancouver'); // if present, index is &gt;= 0
cities_set.indexOf('Ottawa'); // if present, index is &gt;= 0
</code></pre>

<pre><code class="language-erlang">%% At this point, Set5 is the most &quot;recent&quot; set from the standpoint
%% of our application.

riakc_set:is_element(&lt;&lt;&quot;Vancouver&quot;&gt;&gt;, CitiesSet5).
riakc_set:is_element(&lt;&lt;&quot;Ottawa&quot;&gt;&gt;, CitiesSet5).
</code></pre>

<pre><code class="language-curl"># With the HTTP interface, this can be determined from the output of
# a fetch command like the one displayed in the example above
</code></pre>

<p>We can also determine the size of the set:</p>

<pre><code class="language-java">// Using our &quot;citiesSet&quot; from above:

int numberOfCities = citiesSet.size();
</code></pre>

<pre><code class="language-ruby">cities_set.members.length
</code></pre>

<pre><code class="language-php">count($set-&gt;getData());
</code></pre>

<pre><code class="language-python">len(cities_set)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

using System.Linq;

// Note: this enumerates the IEnumerable
setResponse.Values.Count();
</code></pre>

<pre><code class="language-javascript">// Use standard javascript array property length

var cities_set_size = result.values.length;
</code></pre>

<pre><code class="language-erlang">riakc_set:size(CitiesSet5).
</code></pre>

<pre><code class="language-curl"># With the HTTP interface, this can be determined from the output of
# a fetch command like the one displayed in the example above
</code></pre>

<h2 id="maps:31c17b0a2151a3c6671d36d00af76ad6">Maps</h2>

<p>The map is in many ways the richest of the Riak Data Types because all
of the other Data Types can be embedded within them, <em>including maps
themselves</em>, to create arbitrarily complex custom Data Types out of a
few basic building blocks.</p>

<p>The semantics of dealing with counters, sets, and maps within maps are
usually very similar to working with those types at the bucket level,
and so usage is usually very intuitive.</p>

<p>The general syntax for creating a Riak map is directly analogous to the
syntax for creating other data types:</p>

<pre><code class="language-java">// In the Java client, a bucket/bucket type combination is specified
// using a Namespace object. To specify bucket, bucket type, and key,
// use a Location object that incorporates the Namespace object, as is
// done below.

Location map =
  new Location(new Namespace(&quot;&lt;bucket_type&gt;&quot;, &quot;&lt;bucket&gt;&quot;), &quot;&lt;key&gt;&quot;);
</code></pre>

<pre><code class="language-ruby">bucket = client.bucket_type('bucket_type_name').bucket('bucket_name')
map = Riak::Crdt::Map.new(bucket, key)
</code></pre>

<pre><code class="language-php">$location = new \Basho\Riak\Location('key', 'bucket', 'bucket_type');
</code></pre>

<pre><code class="language-python"># The client detects the bucket-type's datatype and automatically
# returns the right datatype for you, in this case a Map.
map = bucket.new(key)

# This way is also acceptable:
from riak.datatypes import Map
map = Map(bucket, key)
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var builder = new UpdateMap.Builder()
    .WithBucketType(&quot;&lt;bucket_type&gt;&quot;)
    .WithBucket(&quot;&lt;bucket&gt;&quot;)
    .WithKey(&quot;&lt;key&gt;&quot;);
</code></pre>

<pre><code class="language-javascript">// Options to pass to the various map methods
var options = {
    bucketType: '&lt;bucket_type&gt;',
    bucket: '&lt;bucket&gt;',
    key: '&lt;key&gt;'
};
</code></pre>

<pre><code class="language-erlang">%% Maps in the Erlang client are opaque data structures that
%% collect operations as you mutate them. We will associate the data
%% structure with a bucket type, bucket, and key later on.
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/&lt;bucket_type&gt;/buckets/&lt;bucket&gt;/datatypes/&lt;key&gt;

# Note that this differs from the URL structure for non-Data Type requests,
# which end in /keys/&lt;key&gt;
</code></pre>

<p>Let&rsquo;s say that we want to use Riak to store information about our
company&rsquo;s customers. We&rsquo;ll use the bucket <code>customers</code> to do so. Each
customer&rsquo;s data will be contained in its own key in the <code>customers</code>
bucket. Let&rsquo;s create a map for the user Ahmed (<code>ahmed_info</code>) (we&rsquo;ll use the
<code>maps</code> bucket type from above):</p>

<pre><code class="language-java">// In the Java client, you specify the location of Data Types
// before you perform operations on them:

Location ahmedMap =
  new Location(new Namespace(&quot;maps&quot;, &quot;customers&quot;), &quot;ahmed_info&quot;);
</code></pre>

<pre><code class="language-ruby">customers = client.bucket_type('maps').bucket('customers')
map = Riak::Crdt::Map.new(customers, 'ahmed_info')

# Alternatively, the Ruby client enables you to set a bucket type as being
# globally associated with a Riak Data Type. The following would set all
# map buckets to use the maps bucket type:

Riak::Crdt::DEFAULT_BUCKET_TYPES[:map] = 'maps'

# This would enable us to create our map without specifying a bucket type:

customers = client.bucket('customers')
map = Riak::Crdt::Map.new(customers, 'ahmed_info')
</code></pre>

<pre><code class="language-php">$location = new \Basho\Riak\Location('ahmed_info', 'customers', 'maps');
</code></pre>

<pre><code class="language-python">customers = client.bucket_type('map_bucket').bucket('customers')
map = customers.net('ahmed_info')
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var builder = new UpdateMap.Builder()
    .WithBucketType(&quot;maps&quot;)
    .WithBucket(&quot;customers&quot;)
    .WithKey(&quot;ahmed_info&quot;);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};
</code></pre>

<pre><code class="language-erlang">Map = riakc_map:new().

%% Maps in the Erlang client are opaque data structures that
%% collect operations as you mutate them. We will associate the data
%% structure with a bucket type, bucket, and key later on.
</code></pre>

<pre><code class="language-curl"># You cannot create an empty map through the HTTP interface. Maps can only
# be created when a field is added to them, as in the examples below.
</code></pre>

<h3 id="registers-and-flags:31c17b0a2151a3c6671d36d00af76ad6">Registers and Flags</h3>

<p>Registers and flags cannot be used on their own in Riak. You cannot use
a bucket/key pair as a register or flag directly.</p>

<h4 id="registers-within-maps:31c17b0a2151a3c6671d36d00af76ad6">Registers Within Maps</h4>

<p>The first piece of info we want to store in our map is Ahmed&rsquo;s name and
phone number, both of which are best stored as registers:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

RegisterUpdate ru1 = new RegisterUpdate(&quot;Ahmed&quot;);
RegisterUpdate ru2 = new RegisterUpdate(&quot;5551234567&quot;);
MapUpdate mu = new MapUpdate()
        .update(&quot;first_name&quot;, ru1)
        .update(&quot;phone_number&quot;, ru2);
UpdateMap update = new UpdateMap.Builder(ahmedMap, mu)
          .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby"># The Ruby client enables you to batch operations together if you're
# performing them on one Data Type.

map.batch do |m|
  m.registers['first_name'] = 'Ahmed'
  m.registers['phone_number'] = '5551234567'
end

# Integers need to be stored as strings and then converted back when
# the data is retrieved. The following would work as well:
map.registers['phone_number'] = 5551234567.to_s
</code></pre>

<pre><code class="language-php">(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateRegister('first_name', 'Ahmed')
    -&gt;updateRegister('phone_number', '5551234567')
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.registers['first_name'].assign('Ahmed')
map.registers['phone_number'].assign('5551234567')

# Integers need to be stored as strings and then converted back when the
# data is retrieved. The following would work as well:
map.registers['phone_number'].assign(str(5551234567))

map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var builder = new UpdateMap.Builder()
    .WithBucketType(&quot;maps&quot;)
    .WithBucket(&quot;customers&quot;)
    .WithKey(&quot;ahmed_info&quot;);

var mapOperation = new UpdateMap.MapOperation();

// Ahmed's first name
mapOperation.SetRegister(&quot;first_name&quot;, &quot;Ahmed&quot;);

// Ahmed's phone number
mapOperation.SetRegister(&quot;phone_number&quot;, &quot;5551234567&quot;);

builder.WithMapOperation(mapOperation);

UpdateMap cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);
MapResponse response = cmd.Response;
PrintMap(response.Value);
// Output as JSON:
// Map: {&quot;Counters&quot;:{},&quot;Sets&quot;:{},&quot;Registers&quot;:{&quot;first_name&quot;:&quot;Ahmed&quot;,&quot;phone_number&quot;:&quot;5551234567&quot;},&quot;Flags&quot;:{},&quot;Maps&quot;:{}}
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.setRegister('first_name', new Buffer('Ahmed'));
mapOp.setRegister('phone_number', new Buffer('5551234567'));

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map1 = riakc_map:update({&lt;&lt;&quot;first_name&quot;&gt;&gt;, register},
                        fun(R) -&gt; riakc_register:set(&lt;&lt;&quot;Ahmed&quot;&gt;&gt;, R) end,
                        Map),
Map2 = riakc_map:update({&lt;&lt;&quot;phone_number&quot;&gt;&gt;, register},
                        fun(R) -&gt; riakc_register:set(&lt;&lt;&quot;5551234567&quot;&gt;&gt;, R) end,
                        Map1).
</code></pre>

<pre><code class="language-curl"># Updates can be performed all at once. The following will create two new
# registers in the map and also set the value of those registers to the
# desired values

curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;first_name_register&quot;: &quot;Ahmed&quot;,
      &quot;phone_number_register&quot;: &quot;5551234567&quot;
    }
  }'
</code></pre>

<p>This will work even though registers <code>first_name</code> and <code>phone_number</code> did
not previously exist, as Riak will create those registers for you.</p>

<h4 id="flags-within-maps:31c17b0a2151a3c6671d36d00af76ad6">Flags Within Maps</h4>

<p>Now let&rsquo;s say that we add an Enterprise plan to our pricing model. We&rsquo;ll
create an <code>enterprise_customer</code> flag to track whether Ahmed has signed
up for the new plan. He hasn&rsquo;t yet, so we&rsquo;ll set it to <code>false</code>:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

MapUpdate mu = new MapUpdate()
        .update(&quot;enterprise_customer&quot;, new FlagUpdate(false));
UpdateMap update = new UpdateMap.Builder(ahmedMap, mu)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.flags['enterprise_customer'] = false
</code></pre>

<pre><code class="language-php">(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateFlag('enterprise_customer', false)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.flags['enterprise_customer'].disable()
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

// Using our builder from above:

mapOperation = new UpdateMap.MapOperation();
mapOperation.SetFlag(&quot;enterprise_customer&quot;, false);

builder.WithMapOperation(mapOperation);
cmd = builder.Build();
rslt = client.Execute(cmd);

response = cmd.Response;

// response.Value as JSON:
// Map: {&quot;Counters&quot;:{},&quot;Sets&quot;:{},
         &quot;Registers&quot;:{&quot;first_name&quot;:&quot;Ahmed&quot;,&quot;phone_number&quot;:&quot;5551234567&quot;},
         &quot;Flags&quot;:{&quot;enterprise_customer&quot;:false},&quot;Maps&quot;:{}}
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.setFlag('enterprise_customer', false);

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map4 = riakc_map:update({&lt;&lt;&quot;enterprise_customer&quot;&gt;&gt;, flag},
                        fun(F) -&gt; riakc_flag:disable(F) end,
                        Map3).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;enterprise_customer_flag&quot;: &quot;disable&quot;
    }
  }'
</code></pre>

<p>We can retrieve the value of that flag at any time:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap).build();
FetchMap.Response response = client.execute(fetch);
RiakMap map = response.getDatatype();
System.out.println(map.getFlag(&quot;enterprise_customer&quot;).view());
</code></pre>

<pre><code class="language-ruby">map.flags['enterprise_customer']

# false
</code></pre>

<pre><code class="language-php">$map = (new \Basho\Riak\Command\Builder\FetchMap($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getMap();

echo $map-&gt;getFlag('enterprise_customer'); // false
</code></pre>

<pre><code class="language-python">map.reload().flags['enterprise_customer'].value
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

Map ahmedMap = response.Value;
ahmedMap.Flags[&quot;enterprise_customer&quot;]
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    console.log(&quot;fetched map: %s&quot;, JSON.stringify(rslt));
});
</code></pre>

<pre><code class="language-erlang">%% The value fetched from Riak is always immutable, whereas the &quot;dirty
%% value&quot; takes into account local modifications that have not been
%% sent to the server.

riakc_map:dirty_value(Map4).
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info
</code></pre>

<h4 id="counters-within-maps:31c17b0a2151a3c6671d36d00af76ad6">Counters Within Maps</h4>

<p>We also want to know how many times Ahmed has visited our website. We&rsquo;ll
use a <code>page_visits</code> counter for that and run the following operation
when Ahmed visits our page for the first time:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

MapUpdate mu = new MapUpdate()
        .update(&quot;page_visits&quot;, cu);
UpdateMap update = new UpdateMap.Builder(ahmedMap, new CounterUpdate(1))
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.counters['page_visits'].increment

# This operation may return false even if successful
</code></pre>

<pre><code class="language-php">$updateCounter = (new \Basho\Riak\Command\Builder\IncrementCounter($riak))
    -&gt;withIncrement(1);

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateCounter('page_visits', $updateCounter)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.counters['page_visits'].increment()
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.IncrementCounter(&quot;page_visits&quot;, 1);

builder.WithMapOperation(mapOperation);
UpdateMap cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);

MapResponse response = cmd.Response;
// Map: {&quot;Counters&quot;:{&quot;page_visits&quot;:3},
         &quot;Sets&quot;:{},
         &quot;Registers&quot;:{&quot;first_name&quot;:&quot;Ahmed&quot;,&quot;phone_number&quot;:&quot;5551234567&quot;},
         &quot;Flags&quot;:{&quot;enterprise_customer&quot;:false},
         &quot;Maps&quot;:{}}
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.incrementCounter('page_visits', 1);

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map3 = riakc_map:update({&lt;&lt;&quot;page_visits&quot;&gt;&gt;, counter},
                        fun(C) -&gt; riakc_counter:increment(1, C) end,
                        Map2).
</code></pre>

<pre><code class="language-curl"># The following will create a new counter and increment it by 1

curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;page_visits_counter&quot;: 1
    }
  }'
</code></pre>

<p>Even though the <code>page_visits</code> counter did not exist previously, the
above operation will create it (with a default starting point of 0) and
the increment operation will bump the counter up to 1.</p>

<h4 id="sets-within-maps:31c17b0a2151a3c6671d36d00af76ad6">Sets Within Maps</h4>

<p>We&rsquo;d also like to know what Ahmed&rsquo;s interests are so that we can better
design a user experience for him. Through his purchasing decisions, we
find out that Ahmed likes robots, opera, and motorcycles. We&rsquo;ll store
that information in a set inside of our map:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

SetUpdate su = new SetUpdate()
        .add(&quot;robots&quot;)
        .add(&quot;opera&quot;)
        .add(&quot;motorcycles&quot;);
MapUpdate mu = new MapUpdate()
        .update(&quot;interests&quot;, su);
UpdateMap update = new UpdateMap.Builder(ahmedMap, mu)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.batch do |m|
  %{ robots opera motorcycles }.each do |interest|
    m.sets['interests'].add(interest)
  end
end
</code></pre>

<pre><code class="language-php">$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('robots')
    -&gt;add('opera')
    -&gt;add('motorcycles');

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateSet('interests', $updateSet)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">for interest in ['robots', 'opera', 'motorcycles']:
    map.sets['interests'].add(interest)
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var interestsAdds = new[] { &quot;robots&quot;, &quot;opera&quot;, &quot;motorcycles&quot; };

var mapOperation = new UpdateMap.MapOperation();
mapOperation.AddToSet(&quot;interests&quot;, interestsAdds);

builder.WithMapOperation(mapOperation);
UpdateMap cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);
MapResponse response = cmd.Response;

// Map: {&quot;Counters&quot;:{&quot;page_visits&quot;:3},
         &quot;Sets&quot;:{&quot;interests&quot;:[&quot;motorcycles&quot;,&quot;opera&quot;,&quot;robots&quot;]},
         &quot;Registers&quot;:{&quot;first_name&quot;:&quot;Ahmed&quot;,&quot;phone_number&quot;:&quot;5551234567&quot;},
         &quot;Flags&quot;:{&quot;enterprise_customer&quot;:false},
         &quot;Maps&quot;:{}}
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.addToSet('interests', 'robots');
mapOp.addToSet('interests', 'opera');
mapOp.addToSet('interests', 'motorcycles');

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map4 = riakc_map:update({&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
                        fun(S) -&gt; riakc_set:add_element(&lt;&lt;&quot;robots&quot;&gt;&gt;, S) end, Map3),
Map5 = riakc_map:update({&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
                        fun(S) -&gt; riakc_set:add_element(&lt;&lt;&quot;opera&quot;&gt;&gt;, S) end,
                        Map4),
Map6 = riakc_map:update({&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
                        fun(S) -&gt; riakc_set:add_element(&lt;&lt;&quot;motorcycles&quot;&gt;&gt;, S) end,
                        Map4).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;interests_set&quot;: {
        &quot;add_all&quot;: [
          &quot;robots&quot;,
          &quot;opera&quot;,
          &quot;motorcycles&quot;
        ]
      }
    }
  }'
</code></pre>

<p>We can then verify that the <code>interests</code> set includes these three
interests:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap)
    .build();
FetchMap.Response response = client.execute(fetch);
RiakMap map = response.getDatatype();
RiakSet interestSet = map.getSet(&quot;interests&quot;);
Set&lt;BinaryValue&gt; interests = interestSet.view();
System.out.println(interests.contains(BinaryValue.create(&quot;robots&quot;)));

// Checking for &quot;opera&quot; and &quot;motorcycles&quot; works the same way
</code></pre>

<pre><code class="language-ruby">map.batch do |m|
  %w{ robots opera motorcycles }.each do |interest|
    m.sets['interests'].include? interest
  end
end

# This will return three Boolean values
</code></pre>

<pre><code class="language-php">$map = (new \Basho\Riak\Command\Builder\FetchMap($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getMap();

$sets = $map-&gt;getSet('interests');
var_dump($sets-&gt;getData());
</code></pre>

<pre><code class="language-python">reloaded_map = map.reload()
for interest in ['robots', 'opera', 'motorcycles']:
    interest in reloaded_map.sets['interests'].value
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

Map ahmedMap = response.Value;

// All of the following return true:
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;robots&quot;);
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;opera&quot;);
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;motorcycles&quot;);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    assert(rslt.map.sets['interests'].indexOf('robots') !== -1);
});
</code></pre>

<pre><code class="language-erlang">riakc_map:dirty_value(Map6).
</code></pre>

<pre><code class="language-curl">curl http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info?include_context=false
</code></pre>

<p>We learn from a recent purchasing decision that Ahmed actually doesn&rsquo;t
seem to like opera. He&rsquo;s much more keen on indie pop. Let&rsquo;s change the
<code>interests</code> set to reflect that:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

SetUpdate su = new SetUpdate()
        .remove(&quot;opera&quot;)
        .add(&quot;indie pop&quot;);
MapUpdate mu = new MapUpdate()
        .update(&quot;interests&quot;, su);
UpdateMap update = new UpdateMap.Builder(ahmedMap, mu)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.batch do |m|
  m.sets['interests'].remove('opera')
  m.sets['interests'].add('indie pop')
end
</code></pre>

<pre><code class="language-php">$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('indie pop')
    -&gt;remove('opera');

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateSet('interests', $updateSet)
    -&gt;atLocation($location)
    -&gt;withContext($map-&gt;getContext())
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.sets['interests'].discard('opera')
map.sets['interests'].add('indie pop')
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.AddToSet(&quot;interests&quot;, &quot;indie pop&quot;);
mapOperation.RemoveFromSet(&quot;interests&quot;, &quot;opera&quot;);

builder
    .WithMapOperation(mapOperation)
    .WithContext(response.Context);

UpdateMap cmd = builder.Build();
RiakResult rslt = client.Execute(cmd);

MapResponse response = cmd.Response;
Map ahmedMap = response.Value;

// This is false
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;opera&quot;);

// These are true
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;indie pop&quot;);
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;robots&quot;);
ahmedMap.Sets.GetValue(&quot;interests&quot;).Contains(&quot;motorcycles&quot;);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
    mapOp.removeFromSet('interests', 'opera');
    mapOp.addToSet('interests', 'indie pop');

    options.context = rslt.context;
    options.op = mapOp;

    client.updateMap(options, function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
});
</code></pre>

<pre><code class="language-erlang">Map7 = riakc_map:update({&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
                        fun(S) -&gt; riakc_set:del_element(&lt;&lt;&quot;opera&quot;&gt;&gt;, S) end, Map6),
Map8 = riakc_map:update({&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
                        fun(S) -&gt; riakc_set:add_element(&lt;&lt;&quot;indie pop&quot;&gt;&gt;, S) end,
                        Map7).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;interests_set&quot;: {
        &quot;remove&quot;: &quot;opera&quot;,
        &quot;add&quot;: &quot;indie pop&quot;
      }
    }
  }
  '
</code></pre>

<h4 id="maps-within-maps-within-maps:31c17b0a2151a3c6671d36d00af76ad6">Maps Within Maps (Within Maps?)</h4>

<p>We&rsquo;ve stored a wide of variety of information&mdash;of a wide variety of
types&mdash;within the <code>ahmed_info</code> map thus far, but we have yet to explore
recursively storing maps within maps (which can be nested as deeply as
you wish).</p>

<p>Our company is doing well and we have lots of useful information about
Ahmed, but now we want to store information about Ahmed&rsquo;s contacts as
well. We&rsquo;ll start with storing some information about Ahmed&rsquo;s colleague
Annika inside of a map called <code>annika_info</code>.</p>

<p>First, we&rsquo;ll store Annika&rsquo;s first name, last name, and phone number in
registers:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

RegisterUpdate ru1 = new RegisterUpdate(&quot;Annika&quot;);
RegisterUpdate ru2 = new RegisterUpdate(&quot;Weiss&quot;);
RegisterUpdate ru3 = new RegisterUpdate(&quot;5559876543&quot;);

MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;first_name&quot;, ru1)
        .update(&quot;last_name&quot;, ru2)
        .update(&quot;phone_number&quot;, ru3);
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].batch do |m|
  m.registers['first_name'] = 'Annika'
  m.registers['last_name'] = 'Weiss'
  m.registers['phone_number'] = 5559876543.to_s
end
</code></pre>

<pre><code class="language-php">$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateRegister('first_name', 'Annika')
    -&gt;updateRegister('last_name', 'Weiss')
    -&gt;updateRegister('phone_number', '5559876543');

$response = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withParameter('returnbody', 'true')
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].registers['first_name'].assign('Annika')
map.maps['annika_info'].registers['last_name'].assign('Weiss')
map.maps['annika_info'].registers['phone_number'].assign(str(5559876543))
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();

var annikaInfoOperation = mapOperation.Map(&quot;annika_info&quot;);
annikaInfoOperation.SetRegister(&quot;first_name&quot;, &quot;Annika&quot;);
annikaInfoOperation.SetRegister(&quot;last_name&quot;, &quot;Weiss&quot;);
annikaInfoOperation.SetRegister(&quot;phone_number&quot;, &quot;5559876543&quot;);

builder.WithMapOperation(mapOperation);
UpdateMap cmd = builder.Build();
client.Execute(cmd);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.map('annika_info')
    .setRegister('first_name', 'Annika')
    .setRegister('last_name', 'Weiss')
    .setRegister('phone_number', '5559876543');

options.op = mapOp;

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map12 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;first_name&quot;&gt;&gt;, register},
        fun(R) -&gt; riakc_register:set(&lt;&lt;&quot;Annika&quot;&gt;&gt;, R) end, M) end,
    Map11),
Map13 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;last_name&quot;&gt;&gt;, register},
        fun(R) -&gt; riakc_register:set(&lt;&lt;&quot;Weiss&quot;&gt;&gt;, R) end, M) end,
    Map12),
Map14 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;phone_number&quot;&gt;&gt;, register},
        fun(R) -&gt; riakc_register:set(&lt;&lt;&quot;5559876543&quot;&gt;&gt;, R) end, M) end,
    Map13).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;update&quot;: {
          &quot;first_name_register&quot;: &quot;Annika&quot;,
          &quot;last_name_register&quot;: &quot;Weiss&quot;,
          &quot;phone_number_register&quot;: &quot;5559876543&quot;
        }
      }
    }
  }
  '
</code></pre>

<p>The value of a register in a map can be obtained without a special
method:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap).build();
FetchMap.Response response = client.execute(fetch);
String annikaFirstName = response.getDatatype()
        .getMap(&quot;annika_info&quot;)
        .getRegister(&quot;first_name&quot;)
        .view()
        .toString();
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].registers['first_name']

# &quot;Annika&quot;
</code></pre>

<pre><code class="language-php"># with param 'returnbody' = 'true', we can fetch the map from our last response
$map-&gt;getMap();

echo $map-&gt;getMap('annika_info')-&gt;getRegister('first_name'); // Annika
</code></pre>

<pre><code class="language-python">map.reload().maps['annika_info'].registers['first_name'].value
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

ahmedMap = response.Value;
ahmedMap.Maps[&quot;annika_info&quot;].Registers.GetValue(&quot;first_name&quot;);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    var annikaFirstName =
        rslt.map.maps['annika_info'].registers['first_name'].toString('utf8');
});
</code></pre>

<pre><code class="language-erlang">riakc_map:dirty_value(Map14).
</code></pre>

<pre><code class="language-curl"># Specific values for fields inside of maps (or maps within maps, for that
# matter), cannot be obtained directly through the HTTP interface.
</code></pre>

<p>Registers can also be removed:</p>

<pre><code class="language-java">// This example uses our &quot;ahmedMap&quot; location from above. Operations that
// remove fields from maps require that you first fetch the opaque context
// attached to the map and then include the context in the update operation:

FetchMap fetch = new FetchMap.Builder(ahmedMap)
    .build();
FetchMap.Response response = client.execute(fetch);
Context ctx = response.getContext();
MapUpdate annikaUpdate = new MapUpdate()
        .removeRegister(&quot;first_name&quot;);
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .withContext(ctx)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].registers.remove('first_name')
</code></pre>

<pre><code class="language-php">$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;removeRegister('first_name');

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withContext($map-&gt;getContext())
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">del map.maps['annika_info'].registers['first_name']
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;).RemoveRegister(&quot;first_name&quot;);

// Note: using Context from last response
builder
    .WithMapOperation(mapOperation)
    .WithContext(response.Context);

UpdateMap cmd = builder.Build();
client.Execute(cmd);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
    mapOp.map('annika_info').removeRegister('first_name');

    var options = {
        bucketType: 'maps',
        bucket: 'customers',
        key: 'ahmed_info',
        op: mapOp,
        context: rslt.context,
    };

    client.updateMap(options, function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
</code></pre>

<pre><code class="language-erlang">Map15 = riakc_map:update({&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
                         fun(M) -&gt; riakc_map:erase({&lt;&lt;&quot;phone_number&quot;&gt;&gt;, register}, M) end,
                         Map14).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;remove&quot;: &quot;phone_number_register&quot;
      }
    }
  }
  '
</code></pre>

<p>Now, we&rsquo;ll store whether Annika is subscribed to a variety of plans
within the company as well:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap).build();
FetchMap.Response response = client.execute(fetch);
Context ctx = response.getContext();
MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;enterprise_plan&quot;, new FlagUpdate((false))
        .update(&quot;family_plan&quot;, new FlagUpdate(false))
        .update(&quot;free_plan&quot;, new FlagUpdate(true));
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .withContext(ctx)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].batch do |m|
  m.flags['enterprise_plan'] = false
  m.flags['family_plan'] = false
  m.flags['free_plan'] = true
end
</code></pre>

<pre><code class="language-php">$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateFlag('enterprise_plan', false)
    -&gt;updateFlag('family_plan', false)
    -&gt;updateFlag('free_plan', true);

$response = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withParameter('returnbody', 'true')
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].flags['enterprise_plan'].disable()
map.maps['annika_info'].flags['family_plan'].disable()
map.maps['annika_info'].flags['free_plan'].enable()
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;)
    .SetFlag(&quot;enterprise_plan&quot;, false)
    .SetFlag(&quot;family_plan&quot;, false)
    .SetFlag(&quot;free_plan&quot;, true);

builder.WithMapOperation(mapOperation);

MapUpdate cmd = builder.Build();
client.Execute(cmd);
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
    var annika_map = mapOp.map('annika_info');
    annika_map.setFlag('enterprise_plan', false);
    annika_map.setFlag('family_plan', false);
    annika_map.setFlag('free_plan', true);

    var options = {
        bucketType: 'maps',
        bucket: 'customers',
        key: 'ahmed_info',
        op: mapOp,
        context: rslt.context,
    };

    client.updateMap(options, function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
});
</code></pre>

<pre><code class="language-erlang">Map16 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;enterprise_plan&quot;&gt;&gt;, flag},
        fun(F) -&gt; riakc_flag:disable(F) end,
        M) end,
    Map15),
Map17 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;family_plan&quot;&gt;&gt;, flag},
        fun(F) -&gt; riakc_flag:disable(F) end,
        M) end,
    Map16),
Map18 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;free_plan&quot;&gt;&gt;, flag},
        fun(F) -&gt; riakc_flag:enable(F) end,
        M) end,
    Map17).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;update&quot;: {
          &quot;enterprise_plan_flag&quot;: &quot;disable&quot;,
          &quot;family_plan_flag&quot;: &quot;disable&quot;,
          &quot;free_plan_flag&quot;: &quot;enable&quot;
        }
      }
    }
  }
  '
</code></pre>

<p>The value of a flag can be retrieved at any time:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap).build();
FetchMap.Response response = client.execute(fetch);
boolean enterprisePlan = response.getDatatype()
        .getMap(&quot;annika_info&quot;)
        .getFlag(&quot;enterprise_plan&quot;)
        .view();
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].flags['enterprise_plan']

# false
</code></pre>

<pre><code class="language-php"># with param 'returnbody' = 'true', we can fetch the map from our last response
$map-&gt;getMap();

echo $map-&gt;getMap('annika_info')-&gt;getFlag('enterprise_plan'); // false
</code></pre>

<pre><code class="language-python">map.reload().maps['annika_info'].flags['enterprise_plan'].value
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

ahmedMap = response.Value;
ahmedMap.Maps[&quot;annika_info&quot;].Flags[&quot;enterprise_plan&quot;];
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    var enterprisePlan =
        rslt.map.maps.annika_info.flags.enterprise_plan;
});
</code></pre>

<pre><code class="language-erlang">riakc_map:dirty_value(Map18).
</code></pre>

<pre><code class="language-curl"># Specific values for fields inside of maps (or maps within maps, for that
# matter), cannot be obtained directly through the HTTP interface.
</code></pre>

<p>It&rsquo;s also important to track the number of purchases that Annika has
made with our company. Annika just made her first widget purchase:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;widget_purchases&quot;, new CounterUpdate(1));
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].counters['widget_purchases'].increment
</code></pre>

<pre><code class="language-php">$updateCounter = (new \Basho\Riak\Command\Builder\IncrementCounter($riak))
    -&gt;withIncrement(1);

$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateCounter('widget_purchases', $updateCounter);

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].counters['widget_purchases'].increment()
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;).IncrementCounter(&quot;widget_purchases&quot;, 1);

builder.WithMapOperation(mapOperation);

UpdateMap cmd = builder.Build();
client.Execute(cmd);
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
mapOp.map('annika_info').incrementCounter('widget_purchases', 1);

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map19 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;widget_purchases&quot;&gt;&gt;, counter},
        fun(C) -&gt; riakc_counter:increment(1, C) end,
        M) end,
    Map18).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;update&quot;: {
          &quot;widget_purchases_counter&quot;: 1
        }
      }
    }
  }
  '
</code></pre>

<p>Now let&rsquo;s store Annika&rsquo;s interests in a set:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

SetUpdate su = new SetUpdate().add(&quot;tango dancing&quot;);
MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;interests&quot;, su);
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].sets['interests'].add('tango dancing')
</code></pre>

<pre><code class="language-php">$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('tango dancing');

$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateSet('interests', $updateSet);

$response = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withParameter('returnbody', 'true')
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].sets['interests'].add('tango dancing')
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;).AddToSet(&quot;interests&quot;, &quot;tango dancing&quot;);

builder.WithMapOperation(mapOperation);
client.Execute(builder.Build());
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
var annika_map = mapOp.map('annika_info');
annika_map.addToSet('interests', 'tango dancing');

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map20 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
        fun(S) -&gt; riakc_set:add_element(&lt;&lt;&quot;tango dancing&quot;&gt;&gt;, S) end,
        M) end,
    Map19).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;update&quot;: {
          &quot;interests_set&quot;: {
            &quot;add&quot;: &quot;tango dancing&quot;
          }
        }
      }
    }
  }
  '
</code></pre>

<p>We can remove that interest in just the way that we would expect:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

SetUpdate su = new SetUpdate().remove(&quot;tango dancing&quot;);
MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;interests&quot;, su);
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .withUpdate(ahmedUpdate)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].sets['interests'].remove('tango dancing')
</code></pre>

<pre><code class="language-php">$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;remove('tango dancing');

$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateSet('interests', $updateSet);

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withContext($response-&gt;getMap()-&gt;getContext())
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].sets['interests'].discard('tango dancing')
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;).RemoveFromSet(&quot;interests&quot;, &quot;tango dancing&quot;);

// Note: using Context from previous response
builder
    .WithMapOperation(mapOperation)
    .WithContext(response.Context);
client.Execute(builder.Build());
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
    var annika_map = mapOp.map('annika_info');
    annika_map.removeFromSet('interests', 'tango dancing');

    options = {
        bucketType: 'maps',
        bucket: 'customers',
        key: 'ahmed_info',
        op: mapOp,
        context: rslt.context
    };

    client.updateMap(options, function (err, rslt) {
        if (err) {
            throw new Error(err);
        }
    });
});
</code></pre>

<pre><code class="language-erlang">Map21 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;interests&quot;&gt;&gt;, set},
        fun(S) -&gt; riakc_set:del_element(&lt;&lt;&quot;tango dancing&quot;&gt;&gt;, S) end,
        M) end,
    Map20).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;interests_set&quot;: {
          &quot;remove&quot;: &quot;tango dancing&quot;
        }
      }
    }
  }
  '
</code></pre>

<p>If we wanted to add store information about one of Annika&rsquo;s specific
purchases, we could do so within a map:</p>

<pre><code class="language-java">// Using our &quot;ahmedMap&quot; location from above:

MapUpdate purchaseUpdate = new MapUpdate()
        .update(&quot;first_purchase&quot;, new FlagUpdate(true)
        .update(&quot;amount&quot;, new RegisterUpdate(&quot;1271&quot;))
        .update(&quot;items&quot;, new SetUpdate().add(&quot;large widget&quot;));
MapUpdate annikaUpdate = new MapUpdate()
        .update(&quot;purchase&quot;, purchaseUpdate);
MapUpdate ahmedUpdate = new MapUpdate()
        .update(&quot;annika_info&quot;, annikaUpdate);
UpdateMap update = new UpdateMap.Builder(ahmedMap, ahmedUpdate)
        .withUpdate(ahmedUpdate)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-ruby">map.maps['annika_info'].maps['purchase'].batch do |m|
  m.flags['first_purchase'] = true
  m.register['amount'] = 1271.to_s
  m.sets['items'].add('large widget')
end
</code></pre>

<pre><code class="language-php">$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;add('large widget');

$purchaseMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateFlag('first_purchase', true)
    -&gt;updateRegister('amount', '1271')
    -&gt;updateSet('items', $updateSet);

$annikaMap = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('purchase', $purchaseMap);

$response = (new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateMap('annika_info', $annikaMap)
    -&gt;atLocation($location)
    -&gt;withParameter('returnbody', 'true')
    -&gt;build()
    -&gt;execute();
</code></pre>

<pre><code class="language-python">map.maps['annika_info'].maps['purchase'].flags['first_purchase'].enable()
map.maps['annika_info'].maps['purchase'].register['amount'].assign(str(1271))
map.maps['annika_info'].maps['purchase'].sets['items'].add('large widget')
# and so on
map.store()
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

var mapOperation = new UpdateMap.MapOperation();
mapOperation.Map(&quot;annika_info&quot;).Map(&quot;purchase&quot;)
    .SetFlag(&quot;first_purchase&quot;, true)
    .SetRegister(&quot;amount&quot;, &quot;1271&quot;)
    .AddToSet(&quot;items&quot;, &quot;large widget&quot;);

builder.WithMapOperation(mapOperation);
client.Execute(builder.Build());
</code></pre>

<pre><code class="language-javascript">var mapOp = new Riak.Commands.CRDT.UpdateMap.MapOperation();
var annika_map = mapOp.map('annika_info');
var annika_purchase_map = annika_map.map('purchase');
annika_purchase_map.setFlag('first_purchase', true);
annika_purchase_map.setRegister('amount', '1271');
annika_purchase_map.addToSet('items', 'large widget');

var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info',
    op: mapOp
};

client.updateMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }
});
</code></pre>

<pre><code class="language-erlang">Map22 = riakc_map:update(
    {&lt;&lt;&quot;annika_info&quot;&gt;&gt;, map},
    fun(M) -&gt; riakc_map:update(
        {&lt;&lt;&quot;purchase&quot;&gt;&gt;, map},
        fun(M) -&gt; riakc_map:update(
            {&lt;&lt;&quot;first_purchase&quot;&gt;&gt;, flag},
            fun(R) -&gt; riakc_flag:enable(R) end,
        M) end,
    M) end,
    Map21
).
</code></pre>

<pre><code class="language-curl">curl -XPOST http://localhost:8098/types/maps/buckets/customers/datatypes/ahmed_info \
  -H &quot;Content-Type: application/json&quot; \
  -d '
  {
    &quot;update&quot;: {
      &quot;annika_info_map&quot;: {
        &quot;update&quot;: {
          &quot;purchase_map&quot;: {
            &quot;update&quot;: {
              &quot;first_purchase_flag&quot;: &quot;enable&quot;,
              &quot;amount_register&quot;: &quot;1271&quot;,
              &quot;items_set&quot;: {
                &quot;add&quot;: &quot;large widget&quot;
              }
            }
          }
        }
      }
    }
  }
  '
</code></pre>

<h2 id="data-types-and-context:31c17b0a2151a3c6671d36d00af76ad6">Data Types and Context</h2>

<p>When performing normal key/value updates in Riak, we advise that you use
[[causal context]], which enables Riak to make intelligent decisions
behind the scenes about which object values should be considered more
causally recent than others in cases of conflict. In some of the
examples above, you saw references to <strong>context</strong> metadata included with
each Data Type stored in Riak.</p>

<p>Data Type contexts are similar to [[causal context]] in that they are
opaque (i.e. not readable by humans) and also perform a similar function
to that of causal context, i.e. they inform Riak which version of the
Data Type a client is attempting to modify. This information is required
by Riak when making decisions about convergence.</p>

<p>In the example below, we&rsquo;ll fetch the context from the user data map we
created for Ahmed, just to see what it looks like:</p>

<pre><code class="language-java">// Using the &quot;ahmedMap&quot; Location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap).build();
FetchMap.Response response = client.execute(fetch);
Context ctx = response.getContext();
System.out.prinntln(ctx.getValue().toString())

// An indecipherable string of Unicode characters should then appear
</code></pre>

<pre><code class="language-ruby">bucket = client.bucket('users')
ahmed_map = Riak::Crdt::Map.new(bucket, 'ahmed_info', 'maps')
ahmed_map.instance_variable_get(:@context)

# =&gt; &quot;\x83l\x00\x00\x00\x01h\x02m\x00\x00\x00\b#\t\xFE\xF9S\x95\xBD3a\x01j&quot;
</code></pre>

<pre><code class="language-php">$map = (new \Basho\Riak\Command\Builder\FetchMap($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getMap();

echo $map-&gt;getContext(); // g2wAAAACaAJtAAAACLQFHUkv4m2IYQdoAm0AAAAIxVKxCy5pjMdhCWo=
</code></pre>

<pre><code class="language-python">bucket = client.bucket_type('maps').bucket('users')
ahmed_map = Map(bucket, 'ahmed_info')
ahmed_map.context

# g2wAAAABaAJtAAAACCMJ/vlTlb0zYQFq
</code></pre>

<pre><code class="language-csharp">// https://github.com/basho/riak-dotnet-client/blob/develop/src/RiakClientExamples/Dev/Using/DataTypes.cs

// Note: using a previous UpdateMap or FetchMap result
Console.WriteLine(format: &quot;Context: {0}&quot;, args: Convert.ToBase64String(result.Context));

// Output:
// Context: g2wAAAACaAJtAAAACLQFHUkv4m2IYQdoAm0AAAAIxVKxCy5pjMdhCWo=
</code></pre>

<pre><code class="language-javascript">var options = {
    bucketType: 'maps',
    bucket: 'customers',
    key: 'ahmed_info'
};

client.fetchMap(options, function (err, rslt) {
    if (err) {
        throw new Error(err);
    }

    logger.info(&quot;context: '%s'&quot;, rslt.context.toString('base64'));
});

// Output:
// context: 'g2wAAAACaAJtAAAACLQFHUmjDf4EYTBoAm0AAAAIxVKxC6F1L2dhSWo='
</code></pre>

<pre><code class="language-erlang">%% You cannot fetch a Data Type's context directly using the Erlang
%% client. This is actually quite all right, as the client automatically
%% manages contexts when making updates.
</code></pre>

<div class="note">
<div class="title">Context with the Ruby, Python, and Erlang clients</div>
In the Ruby, Python, and Erlang clients, you will not need to manually
handle context when making Data Type updates. The clients will do it all
for you. The one exception amongst the official clients is the Java
client. We'll explain how to use Data Type contexts with the Java client
directly below.
</div>

<h4 id="context-with-the-java-and-php-clients:31c17b0a2151a3c6671d36d00af76ad6">Context with the Java and PHP Clients</h4>

<p>With the Java and PHP clients, you&rsquo;ll need to manually fetch and return Data Type
contexts for the following operations:</p>

<ul>
<li>Disabling a flag within a map</li>
<li>Removing an item from a set (whether the set is on its own or within a
map)</li>
<li>Removing a field from a map</li>
</ul>

<p>Without context, these operations simply will not succeed due to the
convergence logic driving Riak Data Types. The example below shows you
how to fetch a Data Type&rsquo;s context and then pass it back to Riak. More
specifically, we&rsquo;ll remove the <code>paid_account</code> flag from the map:</p>

<pre><code class="language-java">// This example uses our &quot;ahmedMap&quot; location from above:

FetchMap fetch = new FetchMap.Builder(ahmedMap)
    .build();
FetchMap.Response response = client.execute(fetch);
Context ctx = response.getContext();
MapUpdate removePaidAccountField = new MapUpdate()
        .removeFlag(&quot;paid_account&quot;);
UpdateMap update = new UpdateMap.Builder(ahmedMap, removePaidAccountField)
        .withContext(ctx)
        .build();
client.execute(update);
</code></pre>

<pre><code class="language-php">$map = (new \Basho\Riak\Command\Builder\FetchMap($riak))
    -&gt;atLocation($location)
    -&gt;build()
    -&gt;execute()
    -&gt;getMap();

$updateSet = (new \Basho\Riak\Command\Builder\UpdateSet($riak))
    -&gt;remove('opera');

(new \Basho\Riak\Command\Builder\UpdateMap($riak))
    -&gt;updateSet('interests', $updateSet)
    -&gt;atLocation($location)
    -&gt;withContext($map-&gt;getContext())
    -&gt;build()
    -&gt;execute();
</code></pre>


      <div class="clear"></div>

    </article>

    <footer class="mastfooter">
    This work is licensed under a
    <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">
        Creative Commons Attribution 4.0 International Public License
    </a><br>
    &copy; 2011-2016&nbsp;<a href="http://www.basho.com">Basho Technologies, Inc.</a>
</footer>


  </div>

  <script src="/js/all.js" type="text/javascript"></script>
<script type= "text/javascript">
  
  hljs.configure({languages: []});
  hljs.initHighlighting();

  
  
  
  $(function() {
    $(".js_enabled pre").css("visibility", "visible");
  });
</script>


</body>
</html>
